{"data":{"site":{"siteMetadata":{"title":"A Tech Blog","author":"Aidan Breen"}},"markdownRemark":{"id":"3cbcaf3a-d04b-5000-8b2a-29cd0f05b8df","excerpt":"This is a piece of code I wrote for a previous blog post about writing a Custom Mocha Reporter. I wanted to generate HTML output from a template, but I didn’t…","html":"<p>This is a piece of code I wrote for a previous blog post about writing a Custom Mocha Reporter. I wanted to generate HTML output from a template, but I didn’t need much functionality or an extra dependency. Turns out, it’s not that difficult.</p>\n<p>Programmatically generating or producing HTML is not rocket science. The typical approach is:</p>\n<ol>\n<li>Build a HTML template close to what you want.</li>\n<li>Identify the variable parts of the template you want to change.</li>\n<li>Write your code to get the replacement parts.</li>\n<li>Use a templating engine to load the HTML and replace the variables with the replacement parts.</li>\n</ol>\n<p>There are loads of templating engines out there. <a href=\"https://www.npmjs.com/package/mustache\">Mustache</a> is one. <a href=\"http://tryhandlebarsjs.com/\">Handlebars</a>, <a href=\"http://olado.github.io/doT/index.html\">doT</a> and <a href=\"http://ejs.co/\">EJS</a> also do the job. They all basically work the same, but they all represent an extra dependency that we don’t need. We’re not doing anything complex here, and I’d rather keep this package with zero dependencies. So build it ourselves.</p>\n<h2>Regular Expressions</h2>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/62d91f4507912c727b85d8883bd8873c/73742/img1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 33.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsSAAALEgHS3X78AAABYElEQVQY0yWQS07DQAyGcysWXIclW1jBERDcoKhiweMAlWBD1QoErWBBaSuaJm2ezSSZTGbymMwrjBLLsn7J/mX7M/KcUso5l7QRUqqibKqat20rlZKq7aNiFaaYScZEwyXjkles1NpYrRPXJxEoE0izvNnYKAixNqjOuYgJl62XO2b6B0o9FeEmT2pgwg2soBH4WYlL14HwAH374PyaCNVCqdE2mXrZyWj5bKdlkwAMQAbs2EIkM/1NnIOCEcP5Xiwe7t3JePn0GHy87cavGar1ztOX9fHd7Gj4eTE29ROT9+n52fnwdjgYDK6vbuZfc6qosfpxoRcmMUFZFcfEMkF/dlhQC9WXk+0sJIQmZmzmGHmpA3HqZe4e7mCVGhBRRPjWRoeo8ANs7VAECiFkj4o0QldQRPrItE72yIY0dfO9gzqz5sy5aDrUOrVNV01Ldcx63pqzbjLBeqFTKI1F/QPTKH8iCGL4ugAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"Figure 1: word replacement.\"\n        title=\"\"\n        src=\"/static/62d91f4507912c727b85d8883bd8873c/40fad/img1.png\"\n        srcset=\"/static/62d91f4507912c727b85d8883bd8873c/707e9/img1.png 148w,\n/static/62d91f4507912c727b85d8883bd8873c/649e0/img1.png 295w,\n/static/62d91f4507912c727b85d8883bd8873c/40fad/img1.png 590w,\n/static/62d91f4507912c727b85d8883bd8873c/73742/img1.png 600w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p><em>Artists impression of a lake surrounded by red cabbage and carrots fields.</em></p>\n<p>Regular expressions (regex) are a <strong>wonderful, powerful and complex</strong> concept that I wont get into in too much detail. Basically, a regular expression allows you to define an “expression”, or pattern, that can be used to find specific sequences in a body of text. A common use of regex is to find a substring, and replace it. Regex can also be used to validate data, ensuring it conforms to some structure (ie. phone numbers contain only numbers and are 10 digits long)</p>\n<h2>Replacing a String.</h2>\n<p>Regex are not unique to Javascript, and even within JS, there are multiple ways to utilise them. In our case, we’ll use the <code class=\"language-text\">string.replace()</code> method. (<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace\">full documentation here</a>)</p>\n<p>str.replace(regexp|substr, newSubstr|function)\nWe’re going to take a string called template and find every occurrence of words surrounded by double squiggly brackets like so: {{word}} . Then we’re going to replace that word with a value we have generated — in the case of the Mocha reporter, we used the output of our tests, but it can be anything at all.</p>\n<p>For example, say we have calculated the percent of tests that ran successfully as: run<em>percent , and in our template we have written {{run</em>percent}} . We could write: template.replace(/{{run<em>precent}}/g, run</em>percent)</p>\n<p>The regex literal is surrounded by forward slashes. The ‘g’ means search globally.\nReplacing Multiple Strings\nBut we can do better. We can find any word surrounded by squigglies with the following regex: /{{.*?}}/g</p>\n<p>. means any character except a newline.</p>\n<ul>\n<li>means match the previous thing 0 or more times.\n? means make the previous thing ‘non-greedy’ — ie. The shortest possible match.\nFinally, we’re not just going to replace every word in squigglies with just one value. If we pass a function as the second parameter to replace(), we can be much smarter…</li>\n</ul>","frontmatter":{"title":"Zero Dependency HTML templating in 12 lines of Javascript","date":"November 12, 2018"}}},"pageContext":{"slug":"/zero-dep-templating/","previous":{"fields":{"slug":"/vivisection-of-opentable-widget/"},"frontmatter":{"title":"Vivisection of OpenTable widget."}},"next":null}}